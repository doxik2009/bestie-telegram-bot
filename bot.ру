import os
import random
import string
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler, ContextTypes
)

# =====================
# –ù–ê–°–¢–†–û–ô–ö–ò –ò–ì–†–´
# =====================

QUESTIONS = [
    {
        "q": "–¢—ã –ø–∏—à–µ—à—å ¬´–æ–∫¬ª ‚Äî —ç—Ç–æ‚Ä¶",
        "a": ["–ù–æ—Ä–º–∞–ª—å–Ω–æ", "–ü–∞—Å—Å–∏–≤–Ω–∞—è –∞–≥—Ä–µ—Å—Å–∏—è", "–§–∏–Ω–∞–ª —Å–µ–∑–æ–Ω–∞ ¬´–î—Ä—É–∂–±–∞¬ª"],
    },
    {
        "q": "–ï—Å–ª–∏ —è –æ–ø–∞–∑–¥—ã–≤–∞—é –Ω–∞ 20 –º–∏–Ω—É—Ç, —Ç—ã‚Ä¶",
        "a": ["–¢–æ–∂–µ –æ–ø–∞–∑–¥—ã–≤–∞—é", "–ú–æ–ª—á–∞ –∑–ª—é—Å—å", "–£–∂–µ –∑–∞–∫–∞–∑–∞–ª–∞ –µ–¥—É –∏ –º–µ–º"],
    },
    {
        "q": "–í –ø–ª–æ—Ö–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏ –º–Ω–µ –ª—É—á—à–µ –ø—Ä–∏—Å–ª–∞—Ç—å‚Ä¶",
        "a": ["–†–∞–∑–≥–æ–≤–æ—Ä", "–ú–µ–º—ã —Å—Ä–æ—á–Ω–æ", "–ï–¥—É. –í—Å–µ–≥–¥–∞ –µ–¥—É."],
    },
    {
        "q": "–ú—ã –º–æ–∂–µ–º –Ω–µ –æ–±—â–∞—Ç—å—Å—è –º–µ—Å—è—Ü –∏ –Ω–µ –æ–±–∏–∂–∞—Ç—å—Å—è?",
        "a": ["–î–∞", "–ù–µ—Ç", "–ó–∞–≤–∏—Å–∏—Ç, –±—ã–ª–∏ –ª–∏ —Å—Ç–æ—Ä–∏—Å"],
    },
    {
        "q": "–ï—Å–ª–∏ –º—ã –ø–æ—Å—Å–æ—Ä–∏–ª–∏—Å—å ‚Äî –∫—Ç–æ –ø–µ—Ä–≤—ã–π –ø—Ä–∏—à–ª—ë—Ç –º–µ–º?",
        "a": ["–Ø", "–û–Ω–∞", "–ú–µ–º –ø—Ä–∏—à–ª—ë—Ç —Å—É–¥—å–±–∞ (–±–æ—Ç)"],
    },
]

VERDICTS = [
    ("üíç –ü–æ–¥—Ä—É–≥–∞ –ø–æ –∂–∏–∑–Ω–∏", "–° –≤–∞–º–∏ –º–æ–∂–Ω–æ –∏ –≤ —Ä–∞–¥–æ—Å—Ç—å, –∏ –≤ –∏–ø–æ—Ç–µ–∫—É."),
    ("‚òï –ü–æ–¥—Ä—É–≥–∞ –ø–æ –∫–æ—Ñ–µ", "–ö–æ—Ñ–µ, —Ä–∞–∑–≥–æ–≤–æ—Ä—ã –∏ –º–µ–º—ã ‚Äî –∏–¥–µ–∞–ª—å–Ω–æ."),
    ("üéâ –ü–æ–¥—Ä—É–≥–∞ –ø–æ –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏—è–º", "–í–µ—Å–µ–ª–æ, –≥—Ä–æ–º–∫–æ –∏ –∏–Ω–æ–≥–¥–∞ –æ–ø–∞—Å–Ω–æ."),
    ("ü§° –û–ø–∞—Å–Ω–æ, –Ω–æ —Å–º–µ—à–Ω–æ", "–ù–∏—á–µ–≥–æ –Ω–µ –ø–æ–Ω—è—Ç–Ω–æ, –Ω–æ –æ—á–µ–Ω—å —Å–º–µ—à–Ω–æ."),
]

FORTUNES = [
    "üîÆ –°—É–¥—å–±–∞ –≥–æ–≤–æ—Ä–∏—Ç: ¬´–∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤—ã–±–æ—Ä‚Ä¶¬ª",
    "üß† –ù–∞—É–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç: —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞.",
    "ü§ù –ú–µ–º—ã —Å–æ–≤–ø–∞–ª–∏. –≠—Ç–æ –∑–Ω–∞–∫.",
    "‚ú® –í—Å–µ–ª–µ–Ω–Ω–∞—è –æ–¥–æ–±—Ä—è–µ—Ç —ç—Ç—É –¥—Ä—É–∂–±—É.",
]

# =====================
# –°–û–°–¢–û–Ø–ù–ò–Ø
# =====================

@dataclass
class PlayerState:
    user_id: int
    answers: List[int] = field(default_factory=list)
    q_index: int = 0


SOLO: Dict[int, PlayerState] = {}

# =====================
# –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï
# =====================

def question_keyboard(q_index: int) -> InlineKeyboardMarkup:
    q = QUESTIONS[q_index]
    buttons = [
        [InlineKeyboardButton(ans, callback_data=f"{q_index}|{i}")]
        for i, ans in enumerate(q["a"])
    ]
    return InlineKeyboardMarkup(buttons)


def pick_verdict(score: int) -> Tuple[str, str]:
    if score >= 80:
        return VERDICTS[0]
    if score >= 60:
        return VERDICTS[2]
    if score >= 40:
        return VERDICTS[1]
    return VERDICTS[3]

# =====================
# –•–≠–ù–î–õ–ï–†–´
# =====================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç üíñ –Ø –∏–≥—Ä–∞ ¬´–¢–∞ —Å–∞–º–∞—è –ø–æ–¥—Ä—É–≥–∞?¬ª\n\n"
        "–ö–æ–º–∞–Ω–¥—ã:\n"
        "/solo ‚Äî —Å—ã–≥—Ä–∞—Ç—å –æ–¥–Ω–æ–π\n"
    )

async def solo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    SOLO[user_id] = PlayerState(user_id=user_id)

    await update.message.reply_text(
        QUESTIONS[0]["q"],
        reply_markup=question_keyboard(0)
    )

async def on_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    q_index, choice = map(int, query.data.split("|"))
    user_id = query.from_user.id

    state = SOLO.get(user_id)
    if not state or q_index != state.q_index:
        return

    state.answers.append(choice)
    state.q_index += 1

    if state.q_index >= len(QUESTIONS):
        score = random.randint(40, 95)
        title, desc = pick_verdict(score)

        await query.edit_message_text("‚úÖ –û—Ç–≤–µ—Ç –∑–∞–ø–∏—Å–∞–Ω")
        await context.bot.send_message(
            chat_id=user_id,
            text=(
                f"{random.choice(FORTUNES)}\n\n"
                f"üìä –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ: {score}%\n\n"
                f"{title}\n{desc}\n\n"
                f"–•–æ—á–µ—à—å —Å—ã–≥—Ä–∞—Ç—å –µ—â—ë —Ä–∞–∑? /solo"
            )
        )
        SOLO.pop(user_id, None)
    else:
        next_q = state.q_index
        await query.edit_message_text("‚úÖ –û—Ç–≤–µ—Ç –∑–∞–ø–∏—Å–∞–Ω")
        await context.bot.send_message(
            chat_id=user_id,
            text=QUESTIONS[next_q]["q"],
            reply_markup=question_keyboard(next_q)
        )

# =====================
# –ó–ê–ü–£–°–ö
# =====================

def main():
    token = os.getenv("BOT_TOKEN")
    if not token:raise RuntimeError("BOT_TOKEN not set")

    app = Application.builder().token(token).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("solo", solo))
    app.add_handler(CallbackQueryHandler(on_answer))

    app.run_polling()

if name == "__main__":
    main(
